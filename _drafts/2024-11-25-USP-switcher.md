---
layout: post
title: "Автоматическое выключение и включение домашнего сервера при перебоях с электричеством"
date: 2024-11-25 17:00:00 +03
modified: 2024-11-25 17:00:00 +03
categories: arduino tcl
tags: [arduino, server, UPS, tcl, raspberry pi, GPIO]
excerpt_separator: <a name="cut"></a>
links_in_new_tab: true
has_scalable_images: true
disqus_page_id: 013343a26RI725I4bg83vAH1Aj35W74NkH766hV23gP0xUg866i4q14hHMWw968m
---
Я очень люблю ардуино и подобные штуки. Но редко когда удаётся по-настоящему что-то такое применить на практике. Ну, потому что, обычно придумать что-то новое и полезное в хозяйстве, чего ещё нет – это очень сложно. А то, что уже придумано и существует проще купить, особенно в век маркетплейсов. Но вот, наконец, настал тот редкий случай, когда получилось сделать простую, но полезную штуку.

У меня есть домашний сервер: git, nextcloud и т.п. Изначально и последние несколько лет он существовал в виде raspberry pi, с подключёнными к ней внешними жёсткими дисками. А ещё иногда случаются небольшие перебои с электричеством. Поэтому первым делом сервер был запитан от ИБП. Но всегда существовала проблема: когда электричество пропадает, то сервер продолжает работать. Мало того, что в этом нет смысла, т.к. без электричества нет и интернета, так ещё, если свет дать не успеют, то ИБП  высаживается в ноль и сервер жёстко завершит свою работу, что однажды привело к тому, что он больше не загрузился. Поэтому требовалось придумать как завершить работу сервера на время отключения электричества. Первая мысль, конечно, это подключить бесперебойник к компьютеру через USB. Но, к сожалению, из этого ничего не вышло. Я провозился пару вечеров, но так и не смог заставить raspberry pi управлять ИБП по USB ни через NUT ни как-то иначе. В итоге настало время хардового решения.

<a name="cut"></a>
Смысл очень простой. Когда электричество отключают, то ардуино подаёт команду серверу. Тот спокойно завершает свою работу, после этого ардуино при помощи сервомашинки нажимает на кнопку на ИБП и тот вырубается. Когда электричество снова появляется, то ардуино снова нажимает на кнопку и малинка включается. Если электричество вернут в процессе отключения сервера, то кнопку потребуется нажать дважды, чтобы снова его включить. Ожидая появления электричества, ардуино будет работать от батареек.
Вроде бы простая идея при разработке в железе требует учесть некоторые нюансы, которые не всегда очевидны. Но в результате появилась следующая схема прибора (кликабельно):

<img alt="Печатная плата" data-src-big="{% link assets/posts/UPS-switcher/circuit.png %}" src="{% link assets/posts/UPS-switcher/circuit_preview.png %}">

Мозгом устройства является Arduino Pro Mini. Для переключения источника питания устройства применяется пятивольтовое реле. Я взял самое маленькое маленькое реле, что у меня было HK4100F. Его кактушка потребляет примерно 40 мА. Диод D1 служит для защиты от обратного тока при переключении катушки. При подаче питания на катушку устройство питается от внешнего источника. Катушка сразу подключена к внешнему питанию, поэтому как только оно появляется, то прибор сразу переходит на него.

![Внешний вид устройства]({% link assets/posts/UPS-switcher/device.jpg %})

При отключении питания катушка отключается и реле переключает питание на батарейное. Я использую 4 батарейки AA, что в сумме даёт напряжение 6В, поэтому требуется уменьшить его до 5 вольт. Для этого используется линейный 5В преобразователь L79L05 в корпусе TO92. Этот преобразователь в холостом режиме потребляет примерно 2,5 мА, поэтому будет сажать батарейки даже если устройство питается от внешнего питания. Чтобы этого не было, предусмотрен транзистор Q1, который полностью размыкает цепь связаннную с батарейками, когда они не должны использоваться и открывается при переходе на батарейное питание при помощи сигнала от ардуино. О наличии внешнего питания ардуино судит по сигналу PWR_STAT.
Ещё для экномии батареек с ардуины удалены светодиод, который горит при подаче питания на ардуино и преобразователь напряжения, который в данном проекте не используется, но потребляет ток. Каждый раз при переключении на батарейки ардуина проверяет напряжение питания. И если оно будет ниже допустимого, то выдаст сообщение об ошибке путём моргания оставшегося светодиода (13-й пин). Проверка напряжения реализована путём переключения АЦП микроконтроллера на измерение внутреннего опорного напряжение 1,1 вольта. При этом опорное напряжение самого АЦП остаётся как обычно - напряжение питания. Поэтому результат измерения 1,1 вольта будет зависеть от напряжения питания.

Чтобы ардуина не выключалась в момент переключения питания предусмотрен конденсатор C2 ёмкостью 3000 мкФ. Но одного конденсатора недостаточно, т.к. из схемы видно, что при отключении внешнего питания, катушка реле продолжит питаться уже от конденсатора и питание быстро не переключится. Чтобы этого избежать установлен диод Шотки. Он съедает примерно 0,2 вольта входного напряжения, поэтому на ардуино приходит примерно 4,8 вольта.

Сервомашинка питается только от батареек, поэтому никак не нагружает блок питания сервера. Также, чтобы электроника сервомашинки не сажала батарейки в простое, предусмотрен транзистор Q2, который открывается ардуиной только на время её работы.

Ардуина общается с сервером при помощи GPIO. Для сервера на Raspberry pi - это не вызывает никаких проблем, т.к. у малинки есть GPIO входы и выходы. Но недавно я перешёл на мини ПК без GPIO. В этом случае потребуется использовать ещё одну ардуино. Но об этом позже. Всего используется два GPIO контакта: COMP_OFF и COMP_STAT.
* COMP_OFF - выходной сигнал ардуино (5-й pin). При высоком уровне на нём сервер получает сигнал о необходимости выключится. Т.к. Raspberry pi использует 3-х вольтовую логику, то COMP_OFF преобразуется во входной сигнал COMP_GPIO_PWR_OFF для Raspbery pi (pin 27) напряжением чуть меньше 3,3 вольта. Для этого используется делитель, в верхнем плече которого резистор на 56 кОм, а в нижнем - на 100 кОм.
* COMP_STAT - это входной сигнал ардуино (6-й pin) с внутренней подтяжкой к высокому уровню. Когда сервер включается, он должен установить на этот контакт низкий уровень. Так ардуино поймёт, что сервер работает, т.к. когда Raspberry pi отключается нулевой уровень на GPIO пропадает. COMP_STAT переходит в выходной для Raspberry pi контакт COMP_GPIO_STAT (pin 22). На всякий случай связь сделана через резистор в 1 кОм.

Ну и конечно прибор должен получать информацию о наличии напряжения в розетке, чтобы понять питаемся мы от бесперибойника или всё нормально: напряжение в сети есть. Для этого был изобретён 😄 самодельный индикатор напряжения в сети в виде обычной неоновой лампочкм NE-2, которая обычно ставится в выключатели и фоторезистора. ~~Лампочка питается от сети через резистор 1 МОм~~.

![Индикатор напряжения в сети в открытом виде]({% link assets/posts/UPS-switcher/line_detector.jpg %})

Всё это дело обматывается изолентой и потом алюминевой фольгой, чтобы надёжно убрать внешний свет. В моём случае фоторезистор в полной темноте имеет сопротивление десятки МОм, а при освещение неоновой лампочкой - сопростивление падает примерно до 700 Ом. Сигнал LINE_STAT формируется из делителя напряжения, где фоторезистор входит в нижнее плечо. Верхнее плечо - резистор на 100 кОм. В этом случае сигнал LINE_STAT является инверсным: когда электричество есть на нём уровень около нуля, а при отключении сети: почти 5 вольт. Для того, чтобы убрать пульсации и случайные срабатывания ставится конденсатор C3. Мне попался на глаза на 22 мкФ. В этом случае детектор срабатывает аж почти через две секунды после отключения электричества в сети.

Позже я переделал эту часть. Для лампочки и фоторезистора распечатал на 3D принтере отдельные корпусы, а потом склеил их. Так надёжней, ничего не нареется и проще менять лампочку. Модель тоже есть в репозитории.
![Индикатор напряжения в сети в распечатанном корпусе]({% link assets/posts/UPS-switcher/line_detector.jpg %})

Серверная часть для Raspberry Pi написана на языке Tcl (файл watcher.tcl) и в работе потребляет всего единицы МБ оперативной памяти. Обычно для управления GPIO Raspberry Pi разработчики используют распространённый, но уже устаревший метод через sysfs. Т.е. записывают значения выводов в специальные файлы, которые предоставляет операционная система. Этот метод используется даже в некоторых библиотеках по работе с GPIO. В тоже время у работы через sysfs много недостатков. Хоть они и не очень существенны в рамках данного проекта, всё же я решил использовать более современный метод, а именно: управление GPIO через библиотеку [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/about/). Это C-библиотека, которую можно использовать в своих программах, но также и готовые утилиты для работы с GPIO. Именно последние я и использовал в своём коде. Для отслеживания входных сигналов применяется утилита gpiomon, а для установки выходных сигналов - gpioset. Одним из преимуществ такого подхода в управлении GPIO является то, что скрипт watcher.tcl имеет монопольный доступ к GPIO и пока его процесс не завершён, никакой другой процесс не может иметь доступа к используемым watcher.tcl GPIO контактактам, что положительно сказывается на безопасности. Библиотека libgpiod уже предустановлена в последних версиях Raspbian OS, но если нет, то её можно установить.

```
sudo apt install gpiod
```

Построив 




4. Расщепление питания для компьютера без GPIO.
5. 