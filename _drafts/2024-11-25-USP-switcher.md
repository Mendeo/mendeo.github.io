---
layout: post
title: "Автоматическое выключение и включение домашнего сервера при перебоях с электричеством"
date: 2024-11-25 17:00:00 +03
modified: 2024-11-25 17:00:00 +03
categories: arduino tcl
tags: [arduino, server, UPS, tcl, raspberry pi, GPIO]
excerpt_separator: <a name="cut"></a>
links_in_new_tab: true
has_scalable_images: true
disqus_page_id: 013343a26RI725I4bg83vAH1Aj35W74NkH766hV23gP0xUg866i4q14hHMWw968m
---
Я очень люблю ардуино и подобные штуки. Но редко когда удаётся по-настоящему что-то такое применить на практике. Ну, потому что, обычно придумать что-то новое и полезное в хозяйстве, чего ещё нет – это очень сложно. А то, что уже придумано и существует проще купить, особенно в век маркетплейсов. Но вот, наконец, настал тот редкий случай, когда получилось сделать простую, но полезную штуку. Но как всегда, когда делаешь что-то простое, обязательно всплывает куча всяких неочевидных нюансов и в итоге всё кратно усложняется, чем думалось в голове.

У меня есть домашний сервер: git, nextcloud и т.п. Изначально и последние несколько лет он существовал в виде raspberry pi, с подключёнными к ней внешними жёсткими дисками. А ещё иногда случаются небольшие перебои с электричеством. Поэтому первым делом сервер был запитан от ИБП. Но всегда существовала проблема: когда электричество пропадает, то сервер продолжает работать. Мало того, что в этом нет смысла, т.к. без электричества нет и интернета, так ещё, если свет дать не успеют, то ИБП  высаживается в ноль и сервер жёстко завершит свою работу, что однажды привело к тому, что он больше не загрузился. Поэтому требовалось придумать как завершить работу сервера на время отключения электричества. Первая мысль, конечно, это подключить бесперебойник к компьютеру через USB. Но, к сожалению, из этого ничего не вышло. Я провозился пару вечеров, но так и не смог заставить raspberry pi управлять ИБП по USB ни через NUT ни как-то иначе. В итоге настало время хардового решения.

<a name="cut"></a>
Смысл очень простой. Состояние электросети отслеживает микроконтроллер в виде ардуино. Когда электричество отключают, то ардуино подаёт команду серверу. Тот спокойно завершает свою работу, после этого ардуино при помощи сервомашинки нажимает на кнопку на ИБП и тот вырубается. Когда электричество снова появляется, то ардуино снова нажимает на кнопку и малинка включается. Если электричество вернут в процессе отключения сервера, то кнопку потребуется нажать дважды, чтобы снова его включить. Ожидая появления электричества, ардуино будет работать от батареек. В результате появилась следующая схема прибора (кликабельно):

<img alt="Печатная плата" data-src-big="{% link assets/posts/UPS-switcher/circuit.png %}" src="{% link assets/posts/UPS-switcher/circuit_preview.png %}">

Мозгом устройства является Arduino Pro Mini. Для переключения источника питания устройства применяется пятивольтовое реле. Я взял самое маленькое маленькое реле, что у меня было HK4100F. Его кактушка потребляет примерно 40 мА. Диод D1 служит для защиты от обратного тока при переключении катушки. При подаче питания на катушку устройство питается от внешнего источника. Катушка сразу подключена к внешнему питанию, поэтому как только оно появляется, то прибор сразу переходит на него.

![Внешний вид устройства]({% link assets/posts/UPS-switcher/device.jpg %})

При отключении питания катушка отключается и реле переключает питание на батарейное. Я использую 4 батарейки AA, что в сумме даёт напряжение 6В, поэтому требуется уменьшить его до 5 вольт. Для этого используется линейный 5В преобразователь L79L05 в корпусе TO92. Этот преобразователь в холостом режиме потребляет примерно 2,5 мА, поэтому будет сажать батарейки даже если устройство питается от внешнего питания. Чтобы этого не было, предусмотрен транзистор Q1, который полностью размыкает цепь связаннную с батарейками, когда они не должны использоваться и открывается при переходе на батарейное питание при помощи сигнала от ардуино. О наличии внешнего питания ардуино судит по сигналу PWR_STAT.
Ещё для экномии батареек с ардуины удалены светодиод, который горит при подаче питания на ардуино и преобразователь напряжения, который в данном проекте не используется, но потребляет ток. Каждый раз при переключении на батарейки ардуина проверяет напряжение питания. И если оно будет ниже допустимого, то выдаст сообщение об ошибке путём моргания оставшегося светодиода (13-й пин). Проверка напряжения реализована путём переключения АЦП микроконтроллера на измерение внутреннего опорного напряжение 1,1 вольта. При этом опорное напряжение самого АЦП остаётся как обычно - напряжение питания. Поэтому результат измерения 1,1 вольта будет зависеть от напряжения питания.

Чтобы ардуина не выключалась в момент переключения питания предусмотрен конденсатор C2 ёмкостью 3000 мкФ. Но одного конденсатора недостаточно, т.к. из схемы видно, что при отключении внешнего питания, катушка реле продолжит питаться уже от конденсатора и питание быстро не переключится. Чтобы этого избежать установлен диод Шотки. Он съедает примерно 0,2 вольта входного напряжения, поэтому на ардуино приходит примерно 4,8 вольта.

Сервомашинка питается только от батареек, поэтому никак не нагружает блок питания сервера. Также, чтобы электроника сервомашинки не сажала батарейки в простое, предусмотрен транзистор Q2, который открывается ардуиной только на время её работы. Я выбрал, наверно, самую распространённую 9-граммовую серву, которую кладут в разные наборы начинающих ардуинщиков. Её я просто приклеил к ИБП на толстый двухсторонний скотч. Для работы с сервой используется стандартная для ардуино библиотека [Servo](https://reference.arduino.cc/reference/en/libraries/servo/). Для настройки угла повотора, достаточного для нажимания кнопки, я сделал небольшую тестовую прошивку, которую можно залить в удобную для тестрования ардуино (Arduino UNO).

```c++
#define LED 13
#define SERVO_CONTROL 4
#include <Servo.h>

Servo _srv;

void setup()
{
  pinMode(LED, OUTPUT);
  pinMode(SERVO_CONTROL, OUTPUT);
  _srv.attach(SERVO_CONTROL);
  Serial.begin(9600);
  _srv.write(0);
}

int _angle = 0;

void loop()
{
  if (Serial.available())
  {
    _angle = Serial.readString().toInt();
    Serial.println(_angle);
    _srv.write(_angle);
    delay(500);
    _srv.write(0);
  }
}
```

 В сериал мониторе нужно вводить градус поворота. Сервомашинка будет на этот угол поворачиваться, а затем возвращаться в нулевое положение. Нужно добиться, чтобы кнопка успешно нажималась и отжималась и сделать на градус два больше для запаса.

![Сервомашинка, приклеенная к ИБП]({% link assets/posts/UPS-switcher/line_detector.jpg %})

Ардуина общается с сервером при помощи GPIO. Для сервера на Raspberry pi - это не вызывает никаких проблем, т.к. у малинки есть GPIO входы и выходы. Но недавно я перешёл на мини ПК без GPIO. В этом случае потребуется использовать ещё одну ардуино. Но об этом позже. Всего используется два GPIO контакта: COMP_OFF и COMP_STAT.
* COMP_OFF - выходной сигнал ардуино (5-й pin). При высоком уровне на нём сервер получает сигнал о необходимости выключится. Т.к. Raspberry pi использует 3-х вольтовую логику, то COMP_OFF преобразуется во входной сигнал COMP_GPIO_PWR_OFF для Raspbery pi (pin 27) напряжением чуть меньше 3,3 вольта. Для этого используется делитель, в верхнем плече которого резистор на 56 кОм, а в нижнем - на 100 кОм.
* COMP_STAT - это входной сигнал ардуино (6-й pin) с внутренней подтяжкой к высокому уровню. Когда сервер включается, он должен установить на этот контакт низкий уровень. Так ардуино поймёт, что сервер работает, т.к. когда Raspberry pi отключается нулевой уровень на GPIO пропадает. COMP_STAT переходит в выходной для Raspberry pi контакт COMP_GPIO_STAT (pin 22). На всякий случай связь сделана через резистор в 1 кОм.

Ну и конечно прибор должен получать информацию о наличии напряжения в розетке, чтобы понять питаемся мы от бесперибойника или всё нормально: напряжение в сети есть. Для этого был изобретён 😄 самодельный индикатор напряжения в сети в виде обычной неоновой лампочкм NE-2, которая обычно ставится в выключатели и фоторезистора. ~~Лампочка питается от сети через резистор 1 МОм~~.

![Индикатор напряжения в сети в открытом виде]({% link assets/posts/UPS-switcher/line_detector.jpg %})

Всё это дело обматывается изолентой и потом алюминевой фольгой, чтобы надёжно убрать внешний свет. В моём случае фоторезистор в полной темноте имеет сопротивление десятки МОм, а при освещение неоновой лампочкой - сопростивление падает примерно до 700 Ом. Сигнал LINE_STAT формируется из делителя напряжения, где фоторезистор входит в нижнее плечо. Верхнее плечо - резистор на 100 кОм. В этом случае сигнал LINE_STAT является инверсным: когда электричество есть на нём уровень около нуля, а при отключении сети: почти 5 вольт. Для того, чтобы убрать пульсации и случайные срабатывания ставится конденсатор C3. Мне попался на глаза на 22 мкФ. В этом случае детектор срабатывает аж почти через две секунды после отключения электричества в сети.

Позже я переделал эту часть. Для лампочки и фоторезистора распечатал на 3D принтере отдельные корпусы, а потом склеил их. Так надёжней, ничего не нареется и проще менять лампочку. Модель тоже есть в репозитории.

![Индикатор напряжения в сети в распечатанном корпусе]({% link assets/posts/UPS-switcher/line_detector.jpg %})

Серверная часть для Raspberry Pi написана на языке Tcl (файл watcher.tcl) и в работе потребляет всего единицы МБ оперативной памяти. Обычно для управления GPIO Raspberry Pi разработчики используют распространённый, но уже устаревший метод через sysfs. Т.е. записывают значения выводов в специальные файлы, которые предоставляет операционная система. Этот метод используется даже в некоторых библиотеках по работе с GPIO. В тоже время, у работы через sysfs много недостатков, наверно главным из которых можно назвать не монопольный доступ к GPIO контактактам, т.е. любые процессы могут писать и читать в GPIO независимо друг от друга. Хоть этот и другие недостатки не очень существенны в рамках данного проекта (теоретически, конечно, может завестись на сервере программа, которая подаст высокий уровень сигнала на пин, отвечающий за выключение и сервер выключится), всё же я решил использовать более современный метод, а именно: управление GPIO через библиотеку [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/about/). Это C-библиотека, которую можно использовать в своих программах, но также и готовые утилиты для работы с GPIO. Именно последние я и использовал в своём коде. Для отслеживания входных сигналов применяется утилита gpiomon, а для установки выходных сигналов - gpioset. Одним из преимуществ такого подхода в управлении GPIO является то, что скрипт watcher.tcl имеет монопольный доступ к GPIO и пока его процесс не завершён, никакой другой процесс не может иметь доступа к используемым watcher.tcl GPIO контактактам, что положительно сказывается на безопасности. Библиотека libgpiod уже предустановлена в последних версиях Raspbian OS, но если нет, то её можно установить.

```
sudo apt install gpiod
```

Построив всю систему для работы с Rspberry pi, я вдруг решил за много лет поменять сервер. Вместо малинки теперь трудится мини ПК, который во много раз шустрее, и в то же время также бесшумный и по размеру примерно такой же. Один минус, в нём нет GPIO! Не беда: заменим GPIO на ещё одну ардуино. На этот раз Arduino nano или любую другую на микроконтроллере Atmega328 или 168, со встроенным usb портом. У меня, кстати, nano на Atmega168p. Серверная программа теперь получает команду на выключение через последовательный порт, а за обмен даннымми с основным устройством через GPIO отвечает новая Arduino. В git репозитории есть код для этой Arduino nano и серверной части (также на языке Tcl). Алгоритм прост: ардуинка всё время шлёт "a\r\n". Когда серверная программа запускается и получает с последовательного порта эту команду, то она отсылает "+". Ардуинка перестаёт слать "a\r\n" и уходит в глубокий сон (почти перестаёт потреблять энергию). Когда настаёт время выключить сервер, то ардуина просыпается и всё время шлёт "-\r\n".

![Мини ПК с Ардуино вместо GPIO]({% link assets/posts/UPS-switcher/device.jpg %})

Но есть и проблема. Если раньше устройство питалось от малинки, то теперь выключенный мини ПК не подаёт питание на USB порты и не включается автоматически при подаче питания. Если последнее легко победить правкой настроек биоса, то с питанием придётся либо переписывать код основного устройства, ухудшая его характеристики, т.к. оно теперь не сможет отслеживать переключение бесперебойника. Либо просто разделить питание от блока питания мини ПК. Я выбрал последний вариант. Во первых, я заменил штатный блок питания (12 вольт, 2,5 ампера), т.к. он сильно грелся и явно не годился для круглосуточной работы. Я же поставил хороший на 5 ампер. В качестве понижающего преобразователя для питания ардуины я решил ничего не придумывать и взял готовый модуль. Теперь всё работает также как и Raspberry pi. Устройство получилось в каком-то смысле универсальным.

![Расщепление питания]({% link assets/posts/UPS-switcher/device.jpg %})

